class Solution {
    public int longestValidParentheses(String s) {
        int l = 0, r = 0, res = 0, n = s.length();
        for (int i = 0; i < n; i++) {
            char c = s.charAt(i);
            if (c == '(') l++;
            else r++;
            if (l == r) res = Math.max(res, 2 * r);
            else if (r > l) {
                l = r = 0;
            }
        }
        l = r = 0;
        for (int i = n - 1; i >= 0; i--) {
            char c = s.charAt(i);
            if (c == ')') l++;
            else r++;
            if (l == r) res = Math.max(res, 2 * r);
            else if (r > l) {
                l = r = 0;
            }
        }
        return res;
    }
}


/*
一个字符串是合法的括号字符串只需要满足两个条件：
1. 左括号和右括号数量相等；
2. 在构建字符串的过程中，没有任何一个节点右括号数量大于左括号。

所以可以用常规的两个变量来记录目前见到了多少个左和右括号。
当左括号等于右括号的时候，就记录一下现在最大合法字符串的长度。
长度是啥呢？就是两倍的左或者右括号数量。
任何一个时刻，如果右括号大于左括号了，那么就重置一下左右括号数量的计数器，继续往下算。

这样做会算错"(()"这个例子，但是如果反着再算一遍，就能搞定这种情况。
这是因为，这样扫描只能在右括号比左括号多的时候立刻返回退出，而左括号比右括号多的时候却无法判断。
因为并不知道这个多余的左括号未来还会不会被match。当到字符串结束时知道了左括号多了，也没法再重置计数器了。
所以要反着扫描一下，把正着扫描左括号更多的情况利用反向扫描把它当“右括号”解决掉。
*/