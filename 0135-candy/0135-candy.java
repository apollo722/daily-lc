class Solution {
    public int candy(int[] ratings) {
        int up = 0, down = 0, peak = 0, res = 1;
        for (int i = 1; i < ratings.length; i++) {
            if (ratings[i] > ratings[i - 1]) {
                down = 0;
                up++;
                peak = up;
                res += up + 1;
            } else if (ratings[i] == ratings[i - 1]) {
                up = 0;
                down = 0;
                peak = 0;
                res += 1;
            } else {
                down++;
                up = 0;
                res += down + 1;
                if (peak >= down) res--;
            }
        }
        return res;
    }
}


/*
如果用一个数组来装每个位置的candy，那么从左扫一遍，把rating更高但candy没更多的都+1，之后再反着来一遍就行。
怎么用O(1)空间解呢？
这里要用爬山的想法。
假如rating是[1,2,3,4]，那么最优分配一定是1，2，3，4直接分配，高位置比低位置多1。
这里不一定是等差数列，只要是递增就可以。
如果是平的，比如都是一样的rating，那么大家都给1就行。这里先不想旁边有更高或更低的情况。
反之如果是递减的，那么也是1，2，3，4这么分配，只是反着来就可以。
所以整个rating相当于很多递增递减平坦段。
递增段就每个位置+1，之后都往结果里加。
如果后一个位置与前一个位置相同，那么这个位置可以是1。怎么想呢？
平坦要么来自于山顶，要么来自于谷底。
如果来自于山顶，顶峰在上升段计算过了，比如1，2，3，3，第二个3分配1块糖没问题，因为第1个3在上升段分配了3块，第二个3分配1块满足要求。
如果来自于谷底，比如3，2，1，1，因为是反向的，所以第一个1处分配了实际上分配了1，即3，2，1，那么第二个1分配1块也没问题。
对于平坦之后变高，也没问题，继续上升段即可。
对于平坦之后变低，或者说上升段之后下降，这里就比较tricky。
比如，[1,2,4,2,1]，分配的糖应该是[1,2,3,2,1]。
如果有平坦段，比如，[1,2,4,4,2,1]，分配的糖应该是[1,2,3,3,2,1]。
对于算法来说，峰顶被计算了两次。什么意思？
比如[1,2,4,2,1]，在看到2时，发现它比前值低，处于下降段，那么按照上升段的写法，down++，res+=down+1，这里会加了2到res。
而上升段遇到第一个2的时候，up++，res+=up+1也是加2到结果。下降段实际应该是+1，之后第二个1处是+2，而算法计算的话变成+2以及+3。
导致这个问题出现的原因是上升段开始并没有去check 1，而是在2处发现了在上升段，从第二个位置开始的。
而下降段的前一个位置已经计算过了，相当于没有从0开始。
[1,2,4,2,1]如果按照算法，每个位置加的应该是1，2，3，2，3，但实际上应该是1，2，3，1，2。所以下降段每个位置都被多加了1，就是因为启动的时候峰顶被重复计算了。
但是不是遇到下降段就要减少呢？也不是，比如例子[1,2,10,9,8,7,6,5]。
算法位置加的是1，2，3，2，3，4，5，6，而实际应该是1，2，6，5，4，3，2，1。观察一下，中间的2和3被多加了1。
也就是说，如果先反着处理下降段，那就会得到1，2，3，4，5，6，之后遇到反着的上升段遇到的2，3，应该被计算成1，2。
也就是说山顶的峰，只有在更长的那段爬坡才是真的峰。
算法上处理就是记录一下上升段爬坡的peak，当下降段的下降小于等于peak的时候，都要减掉1，因为重复计算了。而超过peak的部分说明这边的坡更长了，就不用再减了。
理解比较费劲，写起来就记不住。先记住吧。
*/