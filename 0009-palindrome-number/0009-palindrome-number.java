class Solution {
    public boolean isPalindrome(int x) {
        if (x < 0 || (x != 0 && x % 10 == 0)) return false;
        int rev = 0;
        while (rev < x) {
            int d = x % 10;
            rev = rev * 10 + d;
            x /= 10;
        }
        return x == rev ? true : x == rev / 10;
    }
}


/*
先把很明显的false情况排除，即负数以及非零的能被10整除的数（即尾数是0）。
常规的想法就是把输入翻转的数字求出来并比较，但这样并不最优且还要考虑越界INT的情况。
只转换一半是可以的，但要把输入先转换成str才能求出长度，这样空间也不是很优化。
一个取巧的做法是在转换后数字大于等于前半段数字时就停止。
转换后的数字，即后半段，一旦大于剩下的前半段，证明其位数一定是另一半位数+1。
还有相等的情况，即前后位数恰好一样。那么此时直接返回true。
否则就要去掉一位，即更大的后半段的那位，也就是因为全长为奇数而出现的中心位，之后再比较而这是否相等。
*/