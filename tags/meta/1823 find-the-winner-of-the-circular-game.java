/*
https://leetcode.com/problems/find-the-winner-of-the-circular-game/

一步一步模拟，从最终的case一点点往回推找到safe position
用n=5, k=2举例
0 1 2 3 4
第1轮前，只剩下1个人，那显而易见0是最后被淘汰的人，也就是在只有1个人的情况，0是这轮开始之前的安全位置
第2轮前，有两个人，从前一轮的安全位置开始算，逆向走k步，即0+2=2，2%2=0，所以0依然是这轮开始的安全位置
第3轮前，有三个人，前一轮安全位置0走k步，到了2，而2%3=2，所以2是这轮开始的安全位置，对人数取余是为了防止套圈
第4轮前，有四个人，前一轮安全位置2走k步，到了4，而4%4=0，所以0是这轮开始前的安全位置
第5轮前，有五个人，前一轮安全位置0走k步，到了2，而2%5=2，所以2是这轮开始前的安全位置

所以逆向的反推出来，一开始站在2号位置，五轮之后能活到最后，整个模拟过程就是把一切反过来想
最后+1只是把idx调整成从1开始

Time: O(n)
Space: O(1)
*/

class Solution {
    public int findTheWinner(int n, int k) {
        int res = 0;
        for (int i = 1; i <= n; i++) {
            res = (res + k) % i;
        }
        return res + 1;
    }
}